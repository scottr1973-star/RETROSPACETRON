<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Space Tron — Third-Person CHASE & EVADE with Radar (New Ship)</title>
<style>
  :root{
    --fg:#e6f1ff; --bg0:#060910; --bg1:#0b1530; --hud:#00e0ff;
    --p1:#00f0ff; --p1glow:#7af8ff; --p2:#ff3ad2; --p2glow:#ff83ea;
    --win:#7dff9a; --lose:#ff5a7a; --banner:#101622cc;
  }
  html,body{height:100%;margin:0;background:
    radial-gradient(1200px 800px at 75% 15%,rgba(0,246,255,.08),transparent 60%),
    radial-gradient(1000px 700px at 20% 85%,rgba(255,109,240,.08),transparent 60%),
    linear-gradient(180deg,var(--bg1),var(--bg0));
    color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    overscroll-behavior:none;touch-action:none}
  #host{position:fixed;inset:0;overflow:hidden}
  canvas{display:block;width:100%;height:100%;touch-action:none}

  /* HUD */
  #hudTop{position:absolute;left:12px;top:12px;display:flex;gap:10px;z-index:60;pointer-events:none}
  .pill{background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.12);
        border-radius:999px;padding:6px 10px;font-weight:800;backdrop-filter:blur(3px)}
  #topRight{position:absolute;right:10px;top:10px;display:flex;gap:8px;z-index:60}
  .btn{appearance:none;border:0;border-radius:12px;padding:8px 12px;background:rgba(255,255,255,.12);
       color:var(--fg);font-weight:800;cursor:pointer;backdrop-filter:blur(3px)}
  .btn:active{transform:scale(.98)}
  #hint{position:absolute;left:50%;bottom:10px;transform:translateX(-50%);opacity:.75;font-size:12px;z-index:60;pointer-events:none}

  /* RADAR STYLES (FROM SPACETRON21) */
  #radarWrap{position:absolute;right:10px;bottom:110px;z-index:80;display:flex;flex-direction:column;gap:6px}
  #radarCanvas{width:160px;height:160px;border-radius:10px;background:rgba(0,0,0,.5);
               border:1px solid rgba(255,255,255,.2);backdrop-filter:blur(3px)}
  #radarToolbar{display:flex;gap:6px;justify-content:flex-end}
  #btnRadar{font-size:12px;padding:6px 10px}

  /* Overlays */
  .overlay{position:absolute;inset:0;display:grid;place-items:center;background:rgba(0,0,0,.55);backdrop-filter:blur(6px);z-index:9999}
  .card{background:linear-gradient(180deg,rgba(255,255,255,.07),rgba(255,255,255,.04));border:1px solid rgba(255,255,255,.12);
        border-radius:16px;padding:20px 24px;text-align:center;max-width:560px}
  .row{display:flex;gap:10px;justify-content:center;flex-wrap:wrap}

  /* Mobile buttons only (no joystick) */
  #mobileControls{position:absolute;inset:0;pointer-events:none;z-index:70}
  #turnBtns{position:absolute;left:10px;bottom:10px;display:flex;gap:10px;pointer-events:auto}
  .round{width:72px;height:72px;border-radius:999px;border:0;background:rgba(255,255,255,.12);color:var(--fg);
         font-weight:900;letter-spacing:.6px;box-shadow:0 6px 14px rgba(0,0,0,.35)}
  #btnLeft::before{content:"⟲";font-size:30px}
  #btnRight::before{content:"⟳";font-size:30px}
  #btnBoost{position:absolute;right:10px;bottom:10px;width:88px;height:88px;border-radius:999px;border:0;
            background:linear-gradient(180deg,#ffd35a,#ff9e3d);color:#081017;font-weight:900;letter-spacing:.6px;pointer-events:auto}

  /* Banner for round/match messages (no alerts) */
  #banner{
    position:absolute;left:50%;top:14%;transform:translateX(-50%);
    background:var(--banner);border:1px solid rgba(255,255,255,.15);
    border-radius:12px;padding:10px 14px;font-weight:900;letter-spacing:.6px;
    z-index:80;display:none;text-align:center;min-width:220px
  }
  #banner.win{color:var(--win)} #banner.lose{color:var(--lose)} #banner.info{color:#bde0ff}

  /* Error box */
  #err{position:fixed;left:8px;bottom:8px;max-width:92%;background:#200;padding:8px 10px;color:#fbb;border:1px solid #a33;border-radius:8px;
       font:12px/1.3 monospace;display:none;z-index:10000;white-space:pre-wrap}
</style>
</head>
<body>
<div id="host">
  <canvas id="game"></canvas>

  <div id="hudTop">
    <div class="pill">Round: <span id="round">1</span></div>
    <div class="pill">You: <span id="youWins">0</span> • AI: <span id="aiWins">0</span></div>
    <div class="pill">Speed: <span id="spd">1.0x</span></div>
  </div>

  <div id="topRight">
    <button id="btnPause" class="btn">Pause</button>
    <button id="btnFull" class="btn">Fullscreen</button>
  </div>

  <div id="hint">TURN: ←/→ or A/D • Boost: Shift / BOOST • Press BOOST/Shift to START</div>

  <div id="startOverlay" class="overlay" aria-modal="true" role="dialog">
    <div class="card">
      <h1>Space Tron — CHASE & EVADE (Third-Person)</h1>
      <p>The AI is the **Runner** (evades you). You are the **Hunter** (trap the AI).</p>
      <div class="row" style="margin-top:10px">
        <button id="btnStart" class="btn" autofocus>Start</button>
        <button id="btnHow" class="btn">How to Play</button>
      </div>
      <p style="opacity:.8;font-size:12px;margin-top:8px">Desktop: ←/→ or A/D • **Shift=Boost (1.8x)**. Mobile: ⟲/⟳ and **BOOST (1.8x)**. Press BOOST/Shift to START.</p>
    </div>
  </div>

  <div id="pauseOverlay" class="overlay" style="display:none">
    <div class="card">
      <h2>Paused</h2>
      <div class="row">
        <button id="btnResume" class="btn">Resume</button>
        <button id="btnRestart" class="btn">Restart Match</button>
      </div>
    </div>
  </div>

  <div id="mobileControls">
    <div id="turnBtns">
      <button id="btnLeft" class="round" aria-label="Turn Left"></button>
      <button id="btnRight" class="round" aria-label="Turn Right"></button>
    </div>
    <button id="btnBoost">BOOST</button>
  </div>
  
  <div id="radarWrap">
    <canvas id="radarCanvas" width="160" height="160"></canvas>
    <div id="radarToolbar">
      <button id="btnRadar" class="btn">Radar: M</button>
    </div>
  </div>

  <div id="banner" class="info">Ready</div>
</div>

<div id="err"></div>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script>
/* ===== Crash surface ===== */
window.addEventListener('error', e=>{
  const box=document.getElementById('err'); box.style.display='block';
  box.textContent=(e.error&&e.error.stack)?e.error.stack:(e.message||'Script error');
});

/* ===== DOM ===== */
const canvas=document.getElementById('game');
const roundEl=document.getElementById('round');
const youWinsEl=document.getElementById('youWins');
const aiWinsEl=document.getElementById('aiWins');
const spdEl=document.getElementById('spd');
const btnStart=document.getElementById('btnStart');
const btnHow=document.getElementById('btnHow');
const startOverlay=document.getElementById('startOverlay');
const pauseOverlay=document.getElementById('pauseOverlay');
const btnPause=document.getElementById('btnPause');
const btnFull=document.getElementById('btnFull');
const btnResume=document.getElementById('btnResume');
const btnRestart=document.getElementById('btnRestart');
const btnLeft=document.getElementById('btnLeft');
const btnRight=document.getElementById('btnRight');
const btnBoost=document.getElementById('btnBoost');
const banner=document.getElementById('banner');
const radarCanvas=document.getElementById('radarCanvas');
const radarCtx=radarCanvas.getContext('2d');
const btnRadar=document.getElementById('btnRadar');

// Key tracking
const keys = new Set();

/* ===== Three.js setup ===== */
const renderer=new THREE.WebGLRenderer({canvas,antialias:true,powerPreference:'high-performance'});
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.outputColorSpace=THREE.SRGBColorSpace;
renderer.toneMapping=THREE.ACESFilmicToneMapping; renderer.toneMappingExposure=1.05;

const scene=new THREE.Scene();
scene.fog=new THREE.Fog(0x03060c,140,1600);

const world=new THREE.Group(); scene.add(world);

const camera=new THREE.PerspectiveCamera(70,innerWidth/innerHeight,0.1,4000);
scene.add(camera);

/* Lights */
scene.add(new THREE.HemisphereLight(0x88ccff,0x001015,0.9));
const dl=new THREE.DirectionalLight(0xffffff,0.65); dl.position.set(4,18,10); scene.add(dl);

/* Grid floor (arena) */
const ARENA = { half: 60, y: 0 };
const grid=new THREE.GridHelper(ARENA.half*2, 60*2, 0x00ffff, 0x00ffff);
grid.material.transparent=true; grid.material.opacity=0.25;
grid.position.y = ARENA.y; world.add(grid);

// Arena border
const borderMat = new THREE.LineBasicMaterial({ color:0x00ffff, transparent:true, opacity:0.75 });
const borderGeo = new THREE.BufferGeometry().setFromPoints([
  new THREE.Vector3(-ARENA.half, ARENA.y+0.01, -ARENA.half),
  new THREE.Vector3( ARENA.half, ARENA.y+0.01, -ARENA.half),
  new THREE.Vector3( ARENA.half, ARENA.y+0.01,  ARENA.half),
  new THREE.Vector3(-ARENA.half, ARENA.y+0.01,  ARENA.half),
  new THREE.Vector3(-ARENA.half, ARENA.y+0.01, -ARENA.half),
]);
const border=new THREE.Line(borderGeo, borderMat); world.add(border);

/* ===== Ship builders (New Streamlined Design) ===== */
function buildShip(colorHex){
  const g=new THREE.Group();
  const bodyMat=new THREE.MeshStandardMaterial({color:colorHex, metalness:0.2, roughness:0.4});
  const blackMat=new THREE.MeshStandardMaterial({color:0x101010, roughness:0.9});
  const neonMat=new THREE.MeshBasicMaterial({color:colorHex, transparent:true, opacity:0.95, blending:THREE.AdditiveBlending});

  // Main Body (Sleek Capsule)
  const bodyGeo = new THREE.CapsuleGeometry(0.4, 2.2, 8, 16);
  const body = new THREE.Mesh(bodyGeo, bodyMat);
  body.rotation.x = Math.PI/2; 
  body.position.set(0, 0.6, 0);

  // Cockpit/Canopy (Transparent/darker front section)
  const canopyGeo = new THREE.SphereGeometry(0.32, 16, 12, 0, Math.PI);
  const canopy = new THREE.Mesh(canopyGeo, blackMat);
  canopy.position.set(0, 0.85, 0.6);
  canopy.rotation.x = Math.PI/2;

  // Wings/Stabilizers (Simple flat boxes for side profile)
  const wingGeo = new THREE.BoxGeometry(0.1, 0.05, 1.8);
  const wing = new THREE.Mesh(wingGeo, bodyMat);
  wing.position.set(0.6, 0.6, 0.1);
  wing.rotation.y = Math.PI/2;
  
  const wing2 = new THREE.Mesh(wingGeo, bodyMat);
  wing2.position.set(-0.6, 0.6, 0.1);
  wing2.rotation.y = Math.PI/2;

  // Engine Glow (Rear)
  const glow = new THREE.Mesh(new THREE.PlaneGeometry(0.5, 0.5), neonMat);
  glow.rotation.x = Math.PI/2;
  glow.position.set(0, 0.45, -1.2);
  
  // Outline (Black edge for definition)
  const outline=new THREE.LineSegments(new THREE.EdgesGeometry(bodyGeo),
                      new THREE.LineBasicMaterial({color:0x000000, opacity:0.9, transparent:true}));
  outline.position.y=0.6;


  g.add(body, canopy, wing, wing2, glow, outline);
  return g;
}

/* ===== Game Constants (from 1st person version) ===== */
const wallHeight = 2.0, wallHalf = 0.60; // Thicker walls
const HEAD_RADIUS = 0.30;
const SELF_MIN_MOVE_BEFORE_SELF_HITS = 1.0;
const WALL_SELF_IMMUNE_MS = 400; // Increased self-immunity (0.4s)
const MIN_TRAVEL_BETWEEN_TURNS = 3.0; // Units traveled before another turn is allowed
const NO_REPEAT_SIDE_TIME = 0.45;    // Time until same side turn is allowed again

/* ===== Game State ===== */
const player = {
  ship: buildShip(0x00e0ff),
  pos: new THREE.Vector3(-20, ARENA.y, 0),
  dir: new THREE.Vector3(1,0,0),
  turnCD: 0, speed: 26, boost: 1, alive: true,
  nodes: [], walls: [], color: 0x00e0ff,
  distSinceTurn: 0, lastTurnSide: 0, movedSinceSpawn: 0, _repeatTimer: 0
};
const ai = {
  ship: buildShip(0xff5aa0),
  pos: new THREE.Vector3(20, ARENA.y, 0),
  dir: new THREE.Vector3(-1,0,0),
  turnCD: 0, speed: 31, boost: 1, alive: true, // AI is faster (Runner)
  nodes: [], walls: [], color: 0xff5aa0,
  distSinceTurn: 0, lastTurnSide: 0, movedSinceSpawn: 0, _repeatTimer: 0
};
world.add(player.ship, ai.ship);

/* ===== Audio ===== */
let audioCtx=null, master=null, humP=null, humAI=null;
function audioStart(){
  if(audioCtx) return;
  try{
    audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    master = audioCtx.createGain(); master.gain.value=0.6; master.connect(audioCtx.destination);
    // Player hum (sawtooth + low sine)
    humP = audioCtx.createOscillator(); humP.type='sawtooth';
    const hP=audioCtx.createGain(); hP.gain.value=0.05; humP.connect(hP).connect(master); humP.start();

    const subP = audioCtx.createOscillator(); subP.type='sine';
    const sG=audioCtx.createGain(); sG.gain.value=0.03; subP.connect(sG).connect(master); subP.start();

    // AI hum softer
    humAI = audioCtx.createOscillator(); humAI.type='sawtooth';
    const hA=audioCtx.createGain(); hA.gain.value=0.03; humAI.connect(hA).connect(master); humAI.start();

    // keep references on player/ai for freq updates
    player._hum=[humP,subP]; ai._hum=[humAI];
  }catch(e){ /* audio failed, ignore */ }
}
function setHumFreq(entity){
  if(!audioCtx) return;
  const speed = entity.speed*entity.boost;
  const base = entity===player ? 120 : 100;
  const f = base + speed*2.3;
  if(entity._hum){
    if(entity._hum[0]) entity._hum[0].frequency.setTargetAtTime(f, audioCtx.currentTime, 0.05);
    if(entity._hum[1]) entity._hum[1].frequency.setTargetAtTime(f/2, audioCtx.currentTime, 0.05);
  }
}
function sfxCollision(){
  if(!audioCtx) return;
  const t=audioCtx.currentTime;
  // noise burst
  const dur=0.28, buf=audioCtx.createBuffer(1,audioCtx.sampleRate*dur,audioCtx.sampleRate);
  const d=buf.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*Math.exp(-4*i/d.length);
  const src=audioCtx.createBufferSource(); src.buffer=buf;
  const f=audioCtx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=1400;
  const g=audioCtx.createGain(); g.gain.value=0.9;
  src.connect(f).connect(g).connect(master); src.start(t); src.stop(t+dur);
  // metallic ping
  const o=audioCtx.createOscillator(); o.type='square';
  const og=audioCtx.createGain(); og.gain.value=0.6;
  o.connect(og).connect(master);
  o.frequency.setValueAtTime(800,t); o.frequency.exponentialRampToValueAtTime(200,t+0.25);
  og.gain.setValueAtTime(0.7,t); og.gain.exponentialRampToValueAtTime(0.001,t+0.26);
  o.start(t); o.stop(t+0.28);
}

/* ===== Round/Match State ===== */
let started=false, paused=false;
let youWins=0, aiWins=0, round=1;
youWinsEl.textContent=youWins; aiWinsEl.textContent=aiWins; roundEl.textContent=round; spdEl.textContent='1.0x';
let roundState = 'idle'; // 'idle'|'waiting_start'|'playing'|'over'
let resetTimer = 0;
let mobileBoostHeld = false; // New flag for sustained mobile boost

/* ===== Splash / Start ===== */
function reallyRemove(el){ try{ el.style.display='none'; el.remove(); }catch{} }
function startRound(resetScores=false){
  clearWalls();
  // Consistent start for Chase/Evasion mode
  player.pos.set(-20, ARENA.y, 0); player.dir.set(1,0,0); player.speed=26;
  ai.pos.set(20, ARENA.y, 0); ai.dir.set(-1,0,0); ai.speed=31; // Runner AI is faster
  player.alive=ai.alive=true;
  player.boost=ai.boost=1;
  player.turnCD=ai.turnCD=0;
  player.distSinceTurn=ai.distSinceTurn=0;
  player.lastTurnSide=ai.lastTurnSide=0;
  player._repeatTimer=ai._repeatTimer=0;
  player.movedSinceSpawn = 0; ai.movedSinceSpawn = 0;

  player.walls.length=ai.walls.length=0;
  player._lastDrop = player.pos.clone(); ai._lastDrop = ai.pos.clone();

  updateShipVisual(player); updateShipVisual(ai);

  if(resetScores){ youWins=aiWins=0; youWinsEl.textContent=0; aiWinsEl.textContent=0; round=1; roundEl.textContent=1; }

  // Set to playing if the start button was pressed, or if we're resuming a round
  if(roundState!=='waiting_start'){
    setBanner(`Round ${round}: GO!`, 'info', 900);
    roundState='playing';
  }
  resetTimer=0;
}
function beginGameOnce(){
  if(started) return;
  started=true;
  reallyRemove(startOverlay);
  audioStart();
  roundState = 'waiting_start';
  setBanner('Press BOOST or Shift to start Round 1', 'info', 0);
}

btnStart.addEventListener('click', e=>{ e.preventDefault(); e.stopPropagation(); beginGameOnce(); });
btnHow.addEventListener('click', ()=>{ alert("The AI is the Runner (evades you). You are the Hunter (trap the AI).\nLeft/Right (or A/D) turn 90°. Shift/BOOST for speed (1.8x).\nFirst to 3 wins takes the match."); });
// Start game once on any interaction
startOverlay.addEventListener('click', e=>{ if(e.target===startOverlay) beginGameOnce(); }, {passive:true});
startOverlay.addEventListener('touchstart', e=>{ if(e.target===startOverlay){ e.preventDefault(); beginGameOnce(); } }, {passive:false});

/* ===== Pause / Fullscreen ===== */
btnPause.onclick=()=>{ if(!started) return; paused=!paused; pauseOverlay.style.display=paused?'grid':'none'; };
btnResume.onclick=()=>{ paused=false; pauseOverlay.style.display='none'; };
btnRestart.onclick=()=>{ 
  youWins=aiWins=0; round=1; 
  youWinsEl.textContent=0; aiWinsEl.textContent=0; roundEl.textContent=1; 
  startRound(true); 
  paused=false; pauseOverlay.style.display='none'; 
  roundState = 'waiting_start'; // Ensure new match waits for start signal
  setBanner('Press BOOST or Shift to start Round 1', 'info', 0);
};
btnFull.onclick=()=>{ document.fullscreenElement?document.exitFullscreen():document.documentElement.requestFullscreen?.(); };

/* ===== Trail segments (continuous) ===== */
function neonMaterial(hex){
  return new THREE.MeshBasicMaterial({ color:hex, transparent:true, opacity:0.96, blending:THREE.AdditiveBlending });
}
function addWallSegment(owner, a, b, mat){
  const len = a.clone().setY(0).distanceTo(b.clone().setY(0));
  if(len<0.01) return null;
  const geo = new THREE.BoxGeometry(wallHalf*2, wallHeight, len);
  const mesh = new THREE.Mesh(geo, mat);
  const mid = a.clone().add(b).multiplyScalar(0.5); mid.y = ARENA.y + wallHeight/2;
  mesh.position.copy(mid);
  const angle = Math.atan2(b.x - a.x, b.z - a.z);
  mesh.rotation.y = angle;
  // thin white edge for pop
  const edges = new THREE.LineSegments(new THREE.EdgesGeometry(geo),
                new THREE.LineBasicMaterial({ color:0xffffff, transparent:true, opacity:0.35 }));
  mesh.add(edges);
  world.add(mesh);
  const seg = { a:a.clone(), b:b.clone(), mesh, owner, createdAt: performance.now() };
  (owner==='player'?player.walls:ai.walls).push(seg);
  return seg;
}
function getCSSHex(varName){
  const s=getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
  return parseInt(s.replace('#','0x'));
}
/* Helper: get CSS var value as string for 2D canvas context */
function getCSSStyle(varName) {
  return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
}

const matP = neonMaterial(getCSSHex('--p1'));
const matA = neonMaterial(getCSSHex('--p2'));


/* ===== Geometry & robust collisions (from 1st person version) ===== */
function segSegMinDist2D(a1,a2,b1,b2){
  const u = {x:a2.x-a1.x, z:a2.z-a1.z};
  const v = {x:b2.x-b1.x, z:b2.z-b1.z};
  const w0= {x:a1.x-b1.x, z:a1.z-b1.z};
  const a = u.x*u.x + u.z*u.z;
  const b = u.x*v.x + u.z*v.z;
  const c = v.x*v.x + v.z*v.z;
  const d = u.x*w0.x + u.z*w0.z;
  const e = v.x*w0.x + v.z*w0.z;
  const DEN = a*c - b*b;
  let sc, sN, sD = DEN;
  let tc, tN, tD = DEN;
  const EPS=1e-8;
  if(DEN < EPS){ sN = 0; sD = 1; tN = e; tD = c; }
  else{
    sN = (b*e - c*d); tN = (a*e - b*d);
    if(sN < 0){ sN = 0; tN = e; tD = c; }
    else if(sN > sD){ sN = sD; tN = e + b; tD = c; }
  }
  if(tN < 0){ tN = 0; if(-d < 0) sN = 0; else if(-d > a) sN = sD; else { sN = -d; sD = a; } }
  else if(tN > tD){ tN = tD; if((-d + b) < 0) sN = 0; else if((-d + b) > a) sN = sD; else { sN = (-d + b); sD = a; } }
  sc = (Math.abs(sN) < EPS ? 0 : sN / sD);
  tc = (Math.abs(tN) < EPS ? 0 : tN / tD);
  const dx = w0.x + (sc*u.x) - (tc*v.x);
  const dz = w0.z + (sc*u.z) - (tc*v.z);
  return Math.hypot(dx,dz);
}
function segLen2D(a,b){ const dx=a.x-b.x, dz=a.z-b.z; return Math.hypot(dx,dz); }
function isSameSegment(a1,a2,b1,b2,eps=0.01){
  const d1 = a1.distanceTo(b1) + a2.distanceTo(b2);
  const d2 = a1.distanceTo(b2) + a2.distanceTo(b1);
  return (d1<eps) || (d2<eps);
}
function allLogicalSegments(p, a){
  const list = [...p.walls, ...a.walls];
  function pushProvisional(ent, owner){
    if(ent._lastDrop && ent.pos){
      const a = ent._lastDrop.clone(), b = ent.pos.clone();
      if(a.distanceTo(b) > 0.02){
        list.push({a,b,owner,createdAt: performance.now()});
      }
    }
  }
  pushProvisional(p,'player');
  pushProvisional(a,'ai');
  return list;
}
function sweptHitsAnyWall(prev, curr, owner, nowMs){
  const list = allLogicalSegments(player, ai);
  for(const s of list){
    const own = (s.owner===owner);
    const len = segLen2D(s.a,s.b);
    if(len < 0.02) continue;
    const age = (nowMs - (s.createdAt||nowMs));

    // Use new 400ms self-immunity here
    if(own && age < WALL_SELF_IMMUNE_MS) continue; 

    if(own && isSameSegment(prev,curr,s.a,s.b,0.02)) continue;
    const touchingOwnTip = own && (s.b.distanceTo(prev)<0.25 || s.b.distanceTo(curr)<0.25);
    if(touchingOwnTip) continue;

    const dist = segSegMinDist2D(prev, curr, s.a, s.b);
    if(dist <= (wallHalf + HEAD_RADIUS)) return true;
  }
  return false;
}
function hitIsOnlySelf(prev, curr, owner){
  const list = [...player.walls, ...ai.walls];
  let hitAny=false;
  for(const s of list){
    const own = (s.owner===owner);
    const len = segLen2D(s.a,s.b); if(len<0.02) continue;
    // Exclude the currently forming segment
    if(own && isSameSegment(prev,curr,s.a,s.b,0.02)) continue;
    
    const dist = segSegMinDist2D(prev, curr, s.a, s.b);
    if(dist <= (wallHalf + HEAD_RADIUS)){
      hitAny=true;
      if(!own) return false; // Hit an *other* wall, so it's not ONLY self
    }
  }
  // If hitAny is true, and we never hit an *other* wall, then it's only self.
  return hitAny; 
}
/* ===== Controls (Robust Turn Logic) ===== */
let isTurning = false; // Flag to help prevent rapid key-repeat turns

function doTurn(ship, dir){
  if(!ship.alive || roundState!=='playing') return;
  
  // Robust turn checks
  if(ship.distSinceTurn < MIN_TRAVEL_BETWEEN_TURNS) return;
  if(ship.turnCD>0) return;
  if(ship.lastTurnSide===dir && ship._repeatTimer>0) return;
  
  ship.lastTurnSide = dir;
  ship._repeatTimer = NO_REPEAT_SIDE_TIME;
  ship.turnCD = 0.2; // Cooldown after turn

  const d = ship.dir;
  const ang = (dir<0? -Math.PI/2 : Math.PI/2);
  const nx = Math.round(Math.cos(ang)*d.x - Math.sin(ang)*d.z);
  const nz = Math.round(Math.sin(ang)*d.x + Math.cos(ang)*d.z);
  const newDir = new THREE.Vector3(Math.sign(nx),0,Math.sign(nz));

  // Finalize the segment up to the turn pivot
  if(ship._lastDrop && ship.pos.distanceTo(ship._lastDrop)>0.02){
    addWallSegment(ship===player?'player':'ai', ship._lastDrop, ship.pos, ship===player?matP:matA);
    ship._lastDrop = ship.pos.clone();
  }
  ship.dir.copy(newDir);
  ship.distSinceTurn = 0;
}

// Mobile/Desktop input handling for sustained boost
addEventListener('keydown',e=>{
  keys.add(e.code);
  if(!started || roundState!=='playing') return;
  if(e.repeat) return;
  if(e.code==='ArrowLeft' || e.code==='KeyA') doTurn(player,-1);
  if(e.code==='ArrowRight'|| e.code==='KeyD') doTurn(player, 1);
});
addEventListener('keyup',e=>{ keys.delete(e.code); });

btnLeft.addEventListener('click', ()=>{ if(started && roundState==='playing') doTurn(player,-1); });
btnRight.addEventListener('click', ()=>{ if(started && roundState==='playing') doTurn(player, 1); });

btnBoost.addEventListener('touchstart', ()=>{ if(started) mobileBoostHeld=true; }, {passive:true});
btnBoost.addEventListener('touchend', ()=>{ mobileBoostHeld=false; }, {passive:true});
btnBoost.addEventListener('click', ()=>{ 
  if(roundState==='waiting_start') { 
    startRound(true); // Start the new match if waiting
    roundState = 'playing';
  }
});


/* ===== AI: EVASION RUNNER LOGIC (from 1st person version) ===== */
function rot90(v,dir){
  const ang = (dir<0? -Math.PI/2 : Math.PI/2);
  const nx = Math.round(Math.cos(ang)*v.x - Math.sin(ang)*v.z);
  const nz = Math.round(Math.sin(ang)*v.x + Math.cos(ang)*v.z);
  return new THREE.Vector3(Math.sign(nx),0,Math.sign(nz));
}
function willHitSoon(pos, dir, dist, owner){
  const step = 1.0;
  let prev = pos.clone();
  for(let t=step;t<=dist+1e-3;t+=step){
    const curr = pos.clone().add(dir.clone().multiplyScalar(t));
    if(Math.abs(curr.x)>ARENA.half || Math.abs(curr.z)>ARENA.half) return true;
    if(sweptHitsAnyWall(prev, curr, owner, performance.now())) return true;
    prev.copy(curr);
  }
  return false;
}
function freeDistance(pos, dir, maxDist, owner){
  const step=1.0;
  let prev = pos.clone();
  for(let t=step;t<=maxDist+1e-3;t+=step){
    const curr = pos.clone().add(dir.clone().multiplyScalar(t));
    if(Math.abs(curr.x)>ARENA.half || Math.abs(curr.z)>ARENA.half) return t-step;
    if(sweptHitsAnyWall(prev, curr, owner, performance.now())) return t-step;
    prev.copy(curr);
  }
  return maxDist;
}
function edgeMarginPenalty(pos, dir){
  const m = 6.0; // margin considered "danger zone"
  let pen = 0;
  if(dir.x>0) pen += Math.max(0, m - (ARENA.half - pos.x));
  if(dir.x<0) pen += Math.max(0, m - (pos.x + ARENA.half));
  if(dir.z>0) pen += Math.max(0, m - (ARENA.half - pos.z));
  if(dir.z<0) pen += Math.max(0, m - (pos.z + ARENA.half));
  return pen * 0.1; // scaled down
}

function aiThink(dt){
  if(!ai.alive) return;
  ai.turnCD = Math.max(0, ai.turnCD - dt);
  ai._repeatTimer = Math.max(0, (ai._repeatTimer||0) - dt);

  ai.boost = 1.0; 

  // --- EVASION RUNNER LOGIC (FLEE AND SURVIVE) ---
  const cand = [
    { name:'keep', dir: ai.dir.clone(), turn: 0 },
    { name:'left', dir: rot90(ai.dir,-1), turn: -1 },
    { name:'right',dir: rot90(ai.dir, 1), turn:  1 },
  ];

  let best = null, bestScore = -Infinity;
  for(const c of cand){
    const stepLen = 4.0; 
    const future = ai.pos.clone().add(c.dir.clone().multiplyScalar(stepLen));
    const distToPlayer = future.distanceTo(player.pos);
    
    // SCORING: Maximize distance from player AND open space.
    const fleeFactor = 0.1;
    const spaceFactor = 0.03; 
    const hitPenalty = 5.0;   
    const edgePen = 1.5;      

    const free = freeDistance(ai.pos, c.dir, 22, 'ai'); 
    const edgePenalty = edgeMarginPenalty(future, c.dir);
    const willHit = willHitSoon(ai.pos, c.dir, 16.0, 'ai') ? 1 : 0; 

    // Score: distance from player (flee) + open space - penalties
    const score = (distToPlayer * fleeFactor) + (free * spaceFactor) - (edgePenalty * edgePen) - (willHit * hitPenalty);

    if(score > bestScore){
      bestScore = score; best = c;
    }
  }

  // If turning improves score and we're allowed to turn, do it
  if(best && best.turn !== 0 && ai.turnCD<=0){
    doTurn(ai, best.turn);
    return;
  }

  // Final emergency check for wall hugging
  if(willHitSoon(ai.pos, ai.dir, 16.0, 'ai') && ai.turnCD<=0){
    const leftFree = freeDistance(ai.pos, rot90(ai.dir,-1), 18, 'ai');
    const rightFree= freeDistance(ai.pos, rot90(ai.dir, 1), 18, 'ai');
    if(leftFree > 1.0 || rightFree > 1.0){ // Only turn if there's space
      doTurn(ai, (rightFree>leftFree)? 1 : -1);
      return;
    }
  }
}

/* ===== Radar (from spacetron21) ===== */
const RADAR = { sizeIndex: 1, sizes: [140, 160, 200], maxSeg: 5000 };
btnRadar.addEventListener('click', ()=>{
  RADAR.sizeIndex = (RADAR.sizeIndex+1)%RADAR.sizes.length;
  const s = RADAR.sizes[RADAR.sizeIndex];
  radarCanvas.width = radarCanvas.height = s;
  radarCanvas.style.width = radarCanvas.style.height = s+'px';
  btnRadar.textContent = 'Radar: ' + (['S','M','L'][RADAR.sizeIndex]);
});
function drawRadar(){
  const s = radarCanvas.width, ctx = radarCtx;
  ctx.clearRect(0,0,s,s);
  ctx.fillStyle = 'rgba(5,10,18,0.85)'; ctx.fillRect(0,0,s,s);
  ctx.save(); ctx.globalAlpha = 0.35; ctx.strokeStyle = '#00e0ff'; ctx.lineWidth = 1;
  const cells = 8;
  for(let i=1;i<cells;i++){
    const x = (i/cells)*s;
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,s); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0,x); ctx.lineTo(s,x); ctx.stroke();
  }
  ctx.restore();
  ctx.strokeStyle = 'rgba(0,224,255,0.8)'; ctx.lineWidth = 2; ctx.strokeRect(1,1,s-2,s-2);

  const half = ARENA.half;
  const WX = x => ( (x + half) / (2*half) ) * s;
  const WZ = z => ( (z + half) / (2*half) ) * s;

  function drawTrail(list, color){
    const count = Math.min(list.length, RADAR.maxSeg);
    const start = list.length - count;
    ctx.strokeStyle = color; ctx.lineWidth = 3; ctx.globalAlpha = 1;
    for(let i=start;i<list.length;i++){
      const seg = list[i]; if(!seg) continue;
      const ax = WX(seg.a.x), az = WZ(seg.a.z);
      const bx = WX(seg.b.x), bz = WZ(seg.b.z);
      ctx.beginPath(); ctx.moveTo(ax,az); ctx.lineTo(bx,bz); ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }
  drawTrail(player.walls, '#00f0ff');
  drawTrail(ai.walls, '#ff3ad2');

  function drawBlip(ent, color){
    const x = WX(ent.pos.x), z = WZ(ent.pos.z);
    ctx.fillStyle = color; ctx.strokeStyle = 'white'; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.arc(x,z,5,0,Math.PI*2); ctx.fill(); ctx.stroke();
    const tipX = WX(ent.pos.x + ent.dir.x*4);
    const tipZ = WZ(ent.pos.z + ent.dir.z*4);
    ctx.strokeStyle = color; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(x,z); ctx.lineTo(tipX,tipZ); ctx.stroke();
  }
  drawBlip(player,'#00f0ff'); drawBlip(ai,'#ff3ad2');
}

/* ===== Update / Render ===== */
function updateShipVisual(ent){
  ent.ship.position.copy(ent.pos).add(new THREE.Vector3(0,0.6,0));
  if(ent.dir.x===1)      ent.ship.rotation.y = Math.PI;
  else if(ent.dir.x===-1)ent.ship.rotation.y = 0;
  else if(ent.dir.z===1) ent.ship.rotation.y = -Math.PI/2;
  else if(ent.dir.z===-1)ent.ship.rotation.y = Math.PI/2;
}

/* Walls cleanup */
function clearWalls(){
  for(const s of [...player.walls, ...ai.walls]) world.remove(s.mesh);
  player.walls.length=0; ai.walls.length=0;
}

/* Banner */
function setBanner(text, kind='info', durationMs=1000){
  banner.textContent=text;
  banner.className=''; banner.classList.add(kind==='win'?'win':kind==='lose'?'lose':'info');
  banner.style.display='block';
  if(durationMs>0){
    const now=performance.now();
    const until=now+durationMs;
    (function hideCheck(){
      if(performance.now()>=until){ banner.style.display='none'; return; }
      requestAnimationFrame(hideCheck);
    })();
  }
}

/* Resize */
function resize(){ renderer.setSize(innerWidth,innerHeight); camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); }
addEventListener('resize',resize); resize();

/* Main loop */
let last=performance.now();
requestAnimationFrame(function tick(now){
  const dt=Math.min(0.033,(now-last)/1000); last=now;

  if(started && !paused){
    const boosting = keys.has('ShiftLeft') || keys.has('ShiftRight') || mobileBoostHeld;
    
    // START ROUND WITH BOOST
    if(roundState==='waiting_start'){
      if(boosting){
        startRound(false);
        roundState = 'playing';
      }
      player.boost = 1.0;
    } else if(roundState==='playing'){
      
      // Handle sustained boost
      player.boost = boosting ? 1.8 : 1.0;

      // Cooldowns
      player._repeatTimer = Math.max(0,(player._repeatTimer||0)-dt);
      ai._repeatTimer = Math.max(0,(ai._repeatTimer||0)-dt);
      player.turnCD=Math.max(0,player.turnCD-dt);
      ai.turnCD=Math.max(0,ai.turnCD-dt);

      // AI Logic
      aiThink(dt);

      // Movement
      const pv = player.dir.clone().multiplyScalar(player.speed*player.boost*dt);
      const av = ai.dir.clone().multiplyScalar(ai.speed*ai.boost*dt);
      const prevP = player.pos.clone(), prevA = ai.pos.clone();
      const nextP = prevP.clone().add(pv);
      const nextA = prevA.clone().add(av);
      const nowMs = performance.now();
      
      let endRound=false;

      // PLAYER Collision
      const playerSelfEligible = (player.movedSinceSpawn >= SELF_MIN_MOVE_BEFORE_SELF_HITS);
      const playerHit = sweptHitsAnyWall(prevP, nextP, 'player', nowMs) &&
                        (playerSelfEligible || !hitIsOnlySelf(prevP, nextP,'player'));
      if(playerHit || Math.abs(nextP.x)>ARENA.half || Math.abs(nextP.z)>ARENA.half){
        player.alive=false; endRound=true; sfxCollision();
      }else{
        player.pos.copy(nextP);
        player.movedSinceSpawn += pv.length();
      }

      // AI Collision
      const aiSelfEligible = (ai.movedSinceSpawn >= SELF_MIN_MOVE_BEFORE_SELF_HITS);
      const aiHit = sweptHitsAnyWall(prevA, nextA, 'ai', nowMs) &&
                    (aiSelfEligible || !hitIsOnlySelf(prevA, nextA,'ai'));
      if(aiHit || Math.abs(nextA.x)>ARENA.half || Math.abs(nextA.z)>ARENA.half){
        ai.alive=false; endRound=true; sfxCollision();
      }else{
        ai.pos.copy(nextA);
        ai.movedSinceSpawn += av.length();
      }
      
      player.distSinceTurn += pv.length(); ai.distSinceTurn += av.length();

      // Trails
      dropTrailVisual(player, prevP, player.pos, matP);
      dropTrailVisual(ai, prevA, ai.pos, matA);

      // Camera Follow (Third-Person)
      const camTarget = player.pos.clone().add(new THREE.Vector3(0, 0.6, 0));
      // Position camera 8 units back, 6 units up, slightly to the side based on direction
      const backOffset = player.dir.clone().multiplyScalar(-8);
      const upOffset = new THREE.Vector3(0, 6, 0);
      camera.position.copy(camTarget.clone().add(backOffset).add(upOffset));
      camera.lookAt(camTarget);

      // Update Visuals and Audio
      updateShipVisual(player); updateShipVisual(ai);
      setHumFreq(player); setHumFreq(ai);

      // End Round Check
      if(endRound){
        roundState='over';
        if(player.alive && !ai.alive){ youWins++; youWinsEl.textContent=youWins; setBanner('You trapped the Runner!', 'win', 1500); }
        else if(!player.alive && ai.alive){ aiWins++; aiWinsEl.textContent=aiWins; setBanner('The Runner got away!', 'lose', 1500); }
        else { setBanner('Both crashed!', 'info', 1500); }
        resetTimer = 2.0; 
      }

      spdEl.textContent=(player.boost).toFixed(1)+'x';
      
    }else if(roundState==='over'){
      resetTimer -= dt;
      if(resetTimer<=0){
        if(youWins>=3 || aiWins>=3){
          if(youWins>=3) setBanner('YOU WIN THE MATCH', 'win', 1600);
          else setBanner('AI WINS THE MATCH', 'lose', 1600);
          youWins=aiWins=0; youWinsEl.textContent=0; aiWinsEl.textContent=0; round=1; roundEl.textContent=1;
          roundState = 'waiting_start'; 
          setBanner('Press BOOST or Shift to start New Match', 'info', 0);
        }else{
          round++; roundEl.textContent=round;
          roundState = 'waiting_start';
          setBanner(`Press BOOST or Shift to start Round ${round}`, 'info', 0);
        }
        startRound(false);
      }
    }
  }

  renderer.render(scene,camera);
  if(started) drawRadar();
  requestAnimationFrame(tick);
});

/* Continuous trail helper */
function dropTrailVisual(ent, prev, curr, mat){
  const step=1.0; // Shorter step for smoother trail in third person
  if(!ent._lastDrop) ent._lastDrop = prev.clone();
  const dist = ent._lastDrop.distanceTo(curr);
  if(dist>=step){
    addWallSegment(ent===player?'player':'ai', ent._lastDrop, curr, mat);
    ent._lastDrop = curr.clone();
  }
}
</script>
</body>
</html>